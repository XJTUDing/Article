方法名： matchAndRewrite()
输入：
	要转换的Operation:DSP_VEUSetCtrl0
步骤：
	通过该Operation获取到其操作数。
	声明一个整数变量result,用于保存最终操作的结果
	for every operand do
		按照寄存器的有效位置对result进行移位运算。
	end for
	使用result构造一个Value类型（在IR中是一个SSA) vResult
	LLVM_setCR(CTRL0,vResult)
	在该IR中删除DSP_VEUSetCtrl0节点


class DSP_VEUAsmOp<string me=mnem,list<int> operand, list<OpTrait> traits = ["SideEffect"]> : Op<DSP_Dialect, mnem, traits>

def DSP_VEUAddiiiOp : DSP_VEUAsmOp<"vmadd int int int",operands>;

def DSP_VEUAddcccOp : DSP_VEUAsmOp<"vmadd char char char",operands>;

def DSP_VEUAddsssOp : DSP_VEUAsmOp<"vmadd short short short",operands>;

func @test() {
	dsp.veu_set_ctrl0(0,1,0,0)

	...
	dsp.veu_submulccc(0,1,2,3)

	dsp.return 
}

class DSP_Op<string mnemonic, list<Trait> traits = []> :
  Op<DSP_Dialect, mnemonic, traits> {}

def DSPDma1DTransferInOp : DSP_Op<"dma_1d_transfer_in">,
    Arguments<(ins I8Attr:$priority, I8Attr:$dataType, I64Attr:$ddr_addr, I64Attr:$trans_len, I8Attr:$vmem_array_num, I8Attr:$is_wait)>,
                   Results<(outs I1Attr:$status)> {
 ...
}